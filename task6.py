# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных
# программах в рамках первых трех уроков. Проанализировать результат и определить
# программы с наиболее эффективным использованием памяти.

# Python 3.8.10
# Тип ОС 64-разрядная

from sys import getrefcount as grc

# Задание 1.1 Найти сумму и произведение цифр трехзначного числа, которое вводит пользователь.
num_xxx = int(input("Введите трехзначное число: "))
print(grc(num_xxx)) # 2 или 3

def operations(num):
    hundreds = num // 100
    tens = (num - hundreds * 100) // 10
    ones = num - hundreds * 100 - tens * 10
    their_sum = hundreds + tens + ones
    their_product = hundreds * tens * ones
    return their_sum, their_product

conclusion = operations(num_xxx)
print(conclusion)
print(grc(conclusion)) # 2

print(operations(num_xxx))
print(grc(operations(num_xxx))) # 1

"""
Переменная num_xxx занимает 2 байта, так как целое число;
Внутри функции по 2 байта выделяется под целочисленные переменные hundreds, tens,
ones, their_sum, their_product, в итоге на всех 2 * 5 = 10 байтов и, учитывая
переменную выше, 12 байтов.
Как я понял из методички на всю программу выделено 65.5к байт
"""


# Задание 3.2 Во втором массиве сохранить индексы четных элементов первого массива.
# Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, то во второй массив
# надо заполнить значениями 1, 4, 5, 6 (или 0, 3, 4, 5 - если индексация начинается с нуля),
# т.к. именно в этих позициях первого массива стоят четные числа.

def even_elems_indices(first_list):
    second_list = []
    for idx in range(len(first_list)):
        if first_list[idx] % 2 == 0:
            second_list.append(idx)
    print(grc(second_list)) # 2
    return second_list

print(even_elems_indices([8, 3, 15, 6, 4, 2])) # 98 + 72 = 170
print(even_elems_indices([8, 3, 15, 6, 4, 2, 2, 4, 6, 15, 3, 8])) # 136 + 104 = 240
print(even_elems_indices([8, 8, 8, 8, 8])) # 80 + 80 = 160
print(even_elems_indices([0, 0, 0, 0])) # 72 + 72 = 144
print(even_elems_indices([1, 1, 1, 1, 1, 1])) # 98 + 0 = 98

"""
Если использовать данные из табл. "Автоматическое управление памятью" из методички,
то на каждый список расходуется 40 + 8 * (кол-во элементов) байт.
Таким образом выше в комментарии посчитана затраченная память на указанные списки.
После знака + идет память, затраченная на список индексов четных элементов и далее итог.
Из использованной выше формулы видно линейное увеличение затраченной памяти
в зависимости от увеличения размера списка.
"""

print(grc(even_elems_indices([8, 3, 15, 6, 4, 2]))) # 1
print(grc(even_elems_indices([8, 3, 15, 6, 4, 2, 2, 4, 6, 15, 3, 8]))) # 1
print(grc(even_elems_indices([8, 8, 8, 8, 8]))) # 1
print(grc(even_elems_indices([0, 0, 0, 0]))) # 1
print(grc(even_elems_indices([1, 1, 1, 1, 1, 1]))) # 1

"""
В заключении можно резюмировать, что чем проще тип данных использован в программе,
тем меньше затрачено памяти.
Immutable типы используют меньше памяти, чем mutable типы.
Об эффективности трудно судить, так если использовались числа или строки в небольшом
количестве для переменных, а на программу так или иначе тратится 65.5к байт, то здесь
она низкая,
в тоже время используя коллекции к пределах 65.5к делают программу и быстрее, так как
тип данных продвинутый, и легковесной.
А использование в программе огромных коллекций сделает расход памяти высоким.
Отсюда и делаешь вывод, что при работе с коллекционными типами данных
предпочтительно использовать генераторы, а не загружать в память всю коллекцию,
и правильные алгоритмы.
"""
